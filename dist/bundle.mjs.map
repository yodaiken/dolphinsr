{"version":3,"file":"bundle.mjs","sources":["../lib/types.js","../lib/addReview.js","../lib/dateDiffInDays.js","../lib/computeCardsSchedule.js","../lib/applyReview.js","../lib/index.js"],"sourcesContent":["// @flow\n\nimport uuid from 'uuid';\n\n// Generally all types should be considered opaque in application code.\n\n// -- Data types\n\nexport type Id = string;\nexport function generateId(): Id {\n  return uuid.v4();\n}\n\nexport type Field = string;\n\n// numbers are indexes on master.fields\nexport type Combination = {front: number[], back: number[], };\n\nexport type CardId = string;\nexport function getCardId(o: {master: Id, combination: Combination}): CardId {\n  return `${o.master}#${o.combination.front.join(',')}@${o.combination.back.join(',')}`;\n}\n\n\nexport type Master = {\n  id: Id,\n  fields: Array<Field>,\n  combinations: Array<Combination>,\n}\n\nexport type Rating = 'easy' | 'good' | 'hard' | 'again';\n\nexport type Review = {\n  master: Id,\n  combination: Combination,\n  ts: Date,\n  rating: Rating,\n}\n\n// -- Computed data types\n\nexport type Card = {\n  master: Id,\n  combination: Combination,\n  front: Field[],\n  back: Field[]\n};\n\nexport type LearningCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'learning',\n  consecutiveCorrect: number, // 0 <= consecutiveCorrect < 2, int\n  lastReviewed: ?Date\n};\nexport type ReviewingCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'reviewing',\n  factor: number, // float\n  lapses: number, // int\n  interval: number, // days since lastReviewed\n  lastReviewed: Date\n};\nexport type LapsedCardState = {\n  master: Id,\n  combination: Combination,\n\n  mode: 'lapsed',\n  consecutiveCorrect: number,\n  factor: number,\n  lapses: number,\n  interval: number,\n  lastReviewed: Date,\n};\nexport type CardState = LearningCardState | ReviewingCardState | LapsedCardState;\nexport function makeInitialCardState(master: Id, combination: Combination): LearningCardState {\n  return {\n    master,\n    combination,\n\n    mode: 'learning',\n    consecutiveCorrect: 0,\n    lastReviewed: null,\n  };\n}\n\nexport type State = {\n  cardStates: {[CardId]: CardState},\n};\nexport function makeEmptyState(): State {\n  return {\n    cardStates: {},\n  };\n}\n\nexport type Schedule = 'later' | 'due' | 'overdue' | 'learning';\nexport function cmpSchedule(a: Schedule, b: Schedule) {\n  const scheduleVals = {\n    later: 0,\n    due: 1,\n    overdue: 2,\n    learning: 3,\n  };\n  const diff = scheduleVals[b] - scheduleVals[a];\n  if (diff < 0) {\n    return -1;\n  } else if (diff > 0) {\n    return 1;\n  }\n  return 0;\n}\n\nexport type CardsSchedule = {\n  'later': Array<CardId>,\n  'due': Array<CardId>,\n  'overdue': Array<CardId>,\n  'learning': Array<CardId>\n};\n\nexport type SummaryStatistics = {\n  'later': number,\n  'due': number,\n  'overdue': number,\n  'learning': number\n};\n","// @flow\nimport type { Review } from './types';\n\n// This function only works if reviews is always sorted by timestamp\nexport default function addReview(reviews: Review[], review: Review): Review[] {\n  if (!reviews.length) {\n    return [review];\n  }\n\n  let i = reviews.length - 1;\n  for (; i >= 0; i -= 1) {\n    if (reviews[i].ts <= review.ts) {\n      break;\n    }\n  }\n\n  const newReviews = reviews.slice(0);\n  newReviews.splice(i + 1, 0, review);\n\n  return newReviews;\n}\n","// @flow\n\nexport default function dateDiffInDays(a: Date, b: Date): number {\n  // adapted from http://stackoverflow.com/a/15289883/251162\n  const MS_PER_DAY = 1000 * 60 * 60 * 24;\n\n  // Disstate the time and time-zone information.\n  const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());\n  const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());\n\n  return (utc2 - utc1) / MS_PER_DAY;\n}\n","// @flow\n\nimport type { CardState, ReviewingCardState, Schedule, CardsSchedule, State, CardId } from './types';\nimport { getCardId } from './types';\nimport dateDiffInDays from './dateDiffInDays';\n\n// assumes that the day starts at 3:00am in the local timezone\nexport function calculateDueDate(state: ReviewingCardState): Date {\n  const result = new Date(state.lastReviewed);\n  result.setHours(3, 0, 0);\n  result.setDate(result.getDate() + Math.ceil(state.interval));\n  return result;\n}\n\nexport function computeScheduleFromCardState(state: CardState, now: Date): Schedule {\n  if (state.mode === 'lapsed' || state.mode === 'learning') {\n    return 'learning';\n  } else if (state.mode === 'reviewing') {\n    const diff = dateDiffInDays(calculateDueDate(state), now);\n    if (diff < 0) {\n      return 'later';\n    } else if (diff >= 0 && diff < 1) {\n      return 'due';\n    } else if (diff >= 1) {\n      return 'overdue';\n    }\n  }\n  throw new Error('unreachable');\n}\n\n// Breaks ties first by last review (earlier beats later),\n// then by an alphabetical comparison of the cardId (just so it stays 100% deterministic)\n//\n// Returns null if no cards are due.\nexport function pickMostDue(s: CardsSchedule, state: State): ?CardId {\n  const prec: Schedule[] = ['learning', 'overdue', 'due'];\n  for (let i = 0; i < prec.length; i += 1) {\n    const sched = prec[i];\n    if (s[sched].length) {\n      return s[sched].slice(0).sort((a, b) => {\n        const cardA = state.cardStates[a];\n        const cardB = state.cardStates[b];\n        if (cardA == null) {\n          throw new Error(`id not found in state: ${a}`);\n        }\n        if (cardB == null) {\n          throw new Error(`id not found in state: ${b}`);\n        }\n\n        const reviewDiff = (\n          (cardA.lastReviewed == null && cardB.lastReviewed != null) ? 1 :\n          (cardB.lastReviewed == null && cardA.lastReviewed != null) ? -1 :\n          (cardA.lastReviewed == null && cardB.lastReviewed == null) ? 0 :\n          (cardB.lastReviewed: any) - (cardA.lastReviewed: any)\n        );\n        if (reviewDiff !== 0) {\n          return -reviewDiff;\n        }\n\n        if (a === b) {\n          throw new Error(`comparing duplicate id: ${a}`);\n        }\n        return b > a ? 1 : -1;\n      })[0];\n    }\n  }\n  return null;\n}\n\nexport default function computeCardsSchedule(state: State, now: Date): CardsSchedule {\n  const s: CardsSchedule = {\n    learning: [],\n    later: [],\n    due: [],\n    overdue: [],\n  };\n  Object.keys(state.cardStates).forEach((cardId) => {\n    const cardState = state.cardStates[cardId];\n    s[computeScheduleFromCardState(cardState, now)].push(getCardId(cardState));\n  });\n  return s;\n}\n","// @flow\n\nimport type { State, CardState, LearningCardState, ReviewingCardState, LapsedCardState, Review, Rating } from './types';\nimport { getCardId } from './types';\nimport dateDiffInDays from './dateDiffInDays';\nimport { calculateDueDate } from './computeCardsSchedule';\n\nconst debug = require('debug')('dolphin');\n\n// -- applyToLearningCardState(...)\n\n// constants from Anki defaults\n// TODO(April 1, 2017) investigate rationales, consider changing them\nconst INITIAL_FACTOR = 2500;\nconst INITIAL_DAYS_WITHOUT_JUMP = 4;\nconst INITIAL_DAYS_WITH_JUMP = 1;\nfunction applyToLearningCardState(prev: LearningCardState, ts: Date, rating: Rating): CardState {\n  if (rating === 'easy' || (rating.match(/^easy|good$/) && prev.consecutiveCorrect > 0)) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'reviewing',\n      factor: INITIAL_FACTOR,\n      lapses: 0,\n      interval: prev.consecutiveCorrect > 0 ? INITIAL_DAYS_WITHOUT_JUMP : INITIAL_DAYS_WITH_JUMP,\n      lastReviewed: ts,\n    };\n  } else if (rating === 'again') {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'learning',\n      consecutiveCorrect: 0,\n      lastReviewed: ts,\n    };\n  } else if (rating.match(/^good|hard$/) && prev.consecutiveCorrect < 1) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'learning',\n      consecutiveCorrect: prev.consecutiveCorrect + 1,\n      lastReviewed: ts,\n    };\n  }\n  throw new Error('logic error');\n}\n\n// -- applyToReviewingCardState(...)\n\nconst EASY_BONUS = 2;\nconst MAX_INTERVAL = 365;\nconst MIN_FACTOR = 0; // TODO\nconst MAX_FACTOR = Number.MAX_VALUE;\nfunction constrainWithin(min, max, n) {\n  if (min > max) {\n    throw new Error(`min > max: ${min}=min, ${max}=max`);\n  }\n  return Math.max(Math.min(n, max), min);\n}\n\nfunction calculateDaysLate(state: ReviewingCardState, actual: Date): number {\n  const expected = calculateDueDate(state);\n\n  const daysLate = dateDiffInDays(actual, expected);\n\n  if (daysLate < 0) {\n    debug('last review occured earlier than expected', {\n      daysLate,\n      actual,\n      expected,\n    });\n    return 0;\n  }\n\n  return daysLate;\n}\nfunction applyToReviewingCardState(prev: ReviewingCardState, ts: Date, rating: Rating): CardState {\n  if (rating === 'again') {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'lapsed',\n      consecutiveCorrect: 0,\n      factor: constrainWithin(MIN_FACTOR, MAX_FACTOR, prev.factor - 200),\n      lapses: prev.lapses + 1,\n      interval: prev.interval,\n      lastReviewed: ts,\n    };\n  }\n  const factorAdj = (\n    rating === 'hard' ? -150 :\n    rating === 'good' ? 0 :\n    rating === 'easy' ? 150 :\n    NaN\n  );\n  const daysLate = calculateDaysLate(prev, ts);\n\n  const ival = constrainWithin(prev.interval + 1, MAX_INTERVAL,\n    rating === 'hard' ? (prev.interval + (daysLate / 4)) * 1.2 :\n    rating === 'good' ? ((prev.interval + (daysLate / 2)) * prev.factor) / 1000 :\n    rating === 'easy' ? (((prev.interval + daysLate) * prev.factor) / 1000) * EASY_BONUS :\n    NaN,\n  );\n\n  if (isNaN(factorAdj) || isNaN(ival)) {\n    throw new Error(`invalid rating: ${rating}`);\n  }\n\n  return {\n    master: prev.master,\n    combination: prev.combination,\n\n    mode: 'reviewing',\n    factor: constrainWithin(MIN_FACTOR, MAX_FACTOR, prev.factor + factorAdj),\n    lapses: prev.lapses,\n    interval: ival,\n    lastReviewed: ts,\n  };\n}\n\n// -- applyToLapsedCardState(...)\n\nfunction applyToLapsedCardState(prev: LapsedCardState, ts: Date, rating: Rating): CardState {\n  if (rating === 'easy' || (rating.match(/^easy|good$/) && prev.consecutiveCorrect > 0)) {\n    return {\n      master: prev.master,\n      combination: prev.combination,\n\n      mode: 'reviewing',\n      factor: prev.factor,\n      lapses: prev.lapses,\n      interval: prev.consecutiveCorrect > 0 ? INITIAL_DAYS_WITHOUT_JUMP : INITIAL_DAYS_WITH_JUMP,\n      lastReviewed: ts,\n    };\n  }\n  return {\n    master: prev.master,\n    combination: prev.combination,\n\n    mode: 'lapsed',\n    factor: prev.factor,\n    lapses: prev.lapses,\n    interval: prev.interval,\n    lastReviewed: ts,\n    consecutiveCorrect: rating === 'again' ? 0 : prev.consecutiveCorrect + 1,\n  };\n}\n\n// -- applyReview(...)\n\n\nexport function applyToCardState(prev: CardState, ts: Date, rating: Rating): CardState {\n  if (prev.lastReviewed != null && prev.lastReviewed > ts) {\n    const p = prev.lastReviewed.toISOString();\n    const t = ts.toISOString();\n    throw new Error(`cannot apply review before current lastReviewed: ${p} > ${t}`);\n  }\n\n  if (prev.mode === 'learning') {\n    return applyToLearningCardState((prev: any), ts, rating);\n  } else if (prev.mode === 'reviewing') {\n    return applyToReviewingCardState((prev: any), ts, rating);\n  } else if (prev.mode === 'lapsed') {\n    return applyToLapsedCardState((prev: any), ts, rating);\n  }\n  throw new Error(`invalid mode: ${prev.mode}`);\n}\n\nexport default function applyReview(prev: State, review: Review): State {\n  const cardId = getCardId(review);\n\n  const cardState = prev.cardStates[cardId];\n  if (cardState == null) {\n    throw new Error(`applying review to missing card: ${JSON.stringify(review)}`);\n  }\n\n  const state = {\n    cardStates: { ...prev.cardStates },\n  };\n  state.cardStates[cardId] = applyToCardState(cardState, review.ts, review.rating);\n\n  return state;\n}\n","// @flow\n\nimport type {\n  State, Master, Review, Id, CardId, CardsSchedule, Card, SummaryStatistics,\n} from './types';\nimport { makeEmptyState, getCardId, makeInitialCardState, generateId } from './types';\nimport addReview from './addReview';\nimport applyReview from './applyReview';\nimport computeCardsSchedule, { pickMostDue } from './computeCardsSchedule';\n\nexport type { Master, Review, Id, Card, SummaryStatistics };\nexport { generateId };\n\nconst debug = require('debug')('dolphin');\n\nexport class DolphinSR {\n\n  _state: State;\n  _masters: {[Id]: Master};\n  _reviews: Array<Review>;\n\n  // TODO(April 3, 2017)\n  // Currently the cachedCardsSchedule is not invalidated when the time changes (only when a review\n  // or master is added), so there is a possibility for cards not switching from due to overdue\n  // properly. In practice, this has not been a significant issue -- easy fix for later.\n  _cachedCardsSchedule: ?CardsSchedule;\n\n  // For testing, you can swap this out with a different function to change when 'now' is.\n  _currentDateGetter: () => Date;\n\n\n  constructor(currentDateGetter: () => Date = () => new Date()) {\n    this._state = makeEmptyState();\n    this._masters = {};\n    this._reviews = [];\n    this._currentDateGetter = currentDateGetter;\n  }\n\n  // gotcha: does not invalidate cache, that happens in addMasters()\n  _addMaster(master: Master) {\n    if (this._masters[master.id]) {\n      throw new Error(`master already added: ${master.id}`);\n    }\n    master.combinations.forEach((combination) => {\n      const id = getCardId({ master: master.id, combination });\n      this._state.cardStates[id] = makeInitialCardState(master.id, combination);\n    });\n    this._masters[master.id] = master;\n  }\n\n  addMasters(...masters: Array<Master>) {\n    masters.forEach(master => this._addMaster(master));\n    this._cachedCardsSchedule = null;\n  }\n\n  // gotcha: does not apply the reviews to state or invalidate cache, that happens in addReviews()\n  _addReviewToReviews(review: Review): boolean {\n    this._reviews = addReview(this._reviews, review);\n    const lastReview = this._reviews[this._reviews.length - 1];\n\n    return (\n      `${getCardId(lastReview)}#${lastReview.ts.toISOString()}` !==\n      `${getCardId(review)}#${review.ts.toISOString()}`\n    );\n  }\n\n  // Returns true if the entire state was rebuilt (inefficient, minimize)\n  addReviews(...reviews: Array<Review>): boolean {\n    const needsRebuild = reviews.reduce((v, review) => {\n      if (this._addReviewToReviews(review)) {\n        return true;\n      }\n      return v;\n    }, false);\n\n    if (needsRebuild) {\n      this._rebuild();\n    } else {\n      reviews.forEach((review) => {\n        this._state = applyReview(this._state, review);\n      });\n    }\n\n    this._cachedCardsSchedule = null;\n\n    return needsRebuild;\n  }\n\n  _rebuild() {\n    debug('rebuilding state');\n    const masters = this._masters;\n    const reviews = this._reviews;\n    this._masters = {};\n    this._reviews = [];\n\n    this.addMasters(...Object.keys(masters).map(k => masters[k]));\n    this.addReviews(...reviews);\n  }\n\n  _getCardsSchedule(): CardsSchedule {\n    if (this._cachedCardsSchedule != null) {\n      return this._cachedCardsSchedule;\n    }\n    this._cachedCardsSchedule = computeCardsSchedule(this._state, this._currentDateGetter());\n    return this._cachedCardsSchedule;\n  }\n\n  _nextCardId(): ?CardId {\n    const s = this._getCardsSchedule();\n    return pickMostDue(s, this._state);\n  }\n\n  _getCard(id: CardId): Card {\n    const [masterId, combo] = id.split('#');\n    const [front, back] = combo.split('@').map(part => part.split(',').map(x => parseInt(x, 10)));\n    const master = this._masters[masterId];\n    if (master == null) {\n      throw new Error(`cannot getCard: no such master: ${masterId}`);\n    }\n    const combination = { front, back };\n\n    const frontFields = front.map(i => master.fields[i]);\n    const backFields = back.map(i => master.fields[i]);\n\n    return {\n      master: masterId,\n      combination,\n\n      front: frontFields,\n      back: backFields,\n    };\n  }\n\n  nextCard(): ?Card {\n    const cardId = this._nextCardId();\n    if (cardId == null) {\n      return null;\n    }\n    return this._getCard(cardId);\n  }\n\n  summary(): SummaryStatistics {\n    const s = this._getCardsSchedule();\n    return {\n      due: s.due.length,\n      later: s.later.length,\n      learning: s.learning.length,\n      overdue: s.overdue.length,\n    };\n  }\n}\n"],"names":["generateId","uuid","v4","getCardId","o","master","combination","front","join","back","makeInitialCardState","makeEmptyState","addReview","reviews","review","length","i","ts","newReviews","slice","splice","dateDiffInDays","a","b","MS_PER_DAY","utc1","Date","UTC","getFullYear","getMonth","getDate","utc2","calculateDueDate","state","result","lastReviewed","setHours","setDate","Math","ceil","interval","computeScheduleFromCardState","now","mode","diff","Error","pickMostDue","s","prec","sched","sort","cardA","cardStates","cardB","reviewDiff","computeCardsSchedule","keys","forEach","cardId","cardState","push","debug","require","INITIAL_FACTOR","INITIAL_DAYS_WITHOUT_JUMP","INITIAL_DAYS_WITH_JUMP","applyToLearningCardState","prev","rating","match","consecutiveCorrect","EASY_BONUS","MAX_INTERVAL","MIN_FACTOR","MAX_FACTOR","Number","MAX_VALUE","constrainWithin","min","max","n","calculateDaysLate","actual","expected","daysLate","applyToReviewingCardState","factor","lapses","factorAdj","NaN","ival","isNaN","applyToLapsedCardState","applyToCardState","p","toISOString","t","applyReview","JSON","stringify","DolphinSR","currentDateGetter","_state","_masters","_reviews","_currentDateGetter","id","combinations","masters","_addMaster","_cachedCardsSchedule","lastReview","needsRebuild","reduce","v","_addReviewToReviews","_rebuild","addMasters","Object","map","k","addReviews","_getCardsSchedule","split","masterId","combo","part","parseInt","x","frontFields","fields","backFields","_nextCardId","_getCard","due","later","learning","overdue"],"mappings":"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"}